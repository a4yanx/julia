name: üîß LLVM IR Analysis & Optimization

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  schedule:
    - cron: '0 4 * * *'
  workflow_dispatch:
    inputs:
      target_files:
        description: 'Specific Julia files to analyze (comma-separated, or "all" for everything)'
        required: false
        default: 'all'

env:
  JULIA_NUM_THREADS: auto

jobs:
  # Discover and analyze actual Julia files in the repo
  discover-functions:
    name: üîç Function Discovery
    runs-on: ubuntu-latest
    outputs:
      julia_files: ${{ steps.scan.outputs.julia_files }}
      function_count: ${{ steps.scan.outputs.function_count }}
    steps:
    - uses: actions/checkout@v4
    - uses: julia-actions/setup-julia@v1
      with:
        version: '1.10'
    
    - name: üîç Scan Repository for Julia Functions
      id: scan
      run: |
        julia -e '
        using InteractiveUtils
        
        function scan_repository()
            println("=== Scanning repository for Julia functions ===")
            
            # Find all Julia files
            julia_files = String[]
            for (root, dirs, files) in walkdir(".")
                for file in files
                    if endswith(file, ".jl") && !contains(root, ".git")
                        push!(julia_files, joinpath(root, file))
                    end
                end
            end
            
            println("Found $(length(julia_files)) Julia files")
            for file in julia_files
                println("  üìÑ $file")
            end
            
            # Extract function definitions
            all_functions = []
            
            for file_path in julia_files
                try
                    content = read(file_path, String)
                    lines = split(content, "\n")
                    
                    for (line_num, line) in enumerate(lines)
                        # Match function definitions
                        func_match = match(r"^\s*function\s+([a-zA-Z_][a-zA-Z0-9_!]*)", line)
                        if func_match !== nothing
                            func_name = func_match[1]
                            push!(all_functions, (file_path, line_num, func_name, "function"))
                        end
                        
                        # Match short-form functions
                        short_match = match(r"^\s*([a-zA-Z_][a-zA-Z0-9_!]*)\s*\([^)]*\)\s*=", line)
                        if short_match !== nothing
                            func_name = short_match[1]
                            push!(all_functions, (file_path, line_num, func_name, "short"))
                        end
                        
                        # Match struct constructors and methods
                        struct_match = match(r"^\s*struct\s+([a-zA-Z_][a-zA-Z0-9_!]*)", line)
                        if struct_match !== nothing
                            struct_name = struct_match[1]
                            push!(all_functions, (file_path, line_num, struct_name, "struct"))
                        end
                    end
                catch e
                    println("‚ö†Ô∏è  Error reading $file_path: $e")
                end
            end
            
            println("\nFound $(length(all_functions)) function definitions:")
            for (file, line, name, type) in all_functions
                println("  $type: $name at $file:$line")
            end
            
            # Save results for GitHub Actions
            open("functions.txt", "w") do io
                for (file, line, name, type) in all_functions
                    println(io, "$file,$line,$name,$type")
                end
            end
            
            open("julia_files.txt", "w") do io
                for file in julia_files
                    println(io, file)
                end
            end
            
            return julia_files, all_functions
        end
        
        julia_files, functions = scan_repository()
        '
        
        # Set outputs for GitHub Actions
        echo "julia_files=$(cat julia_files.txt | tr '\n' ',')" >> $GITHUB_OUTPUT
        echo "function_count=$(wc -l < functions.txt)" >> $GITHUB_OUTPUT
    
    - name: ‚¨ÜÔ∏è Upload Function Discovery
      uses: actions/upload-artifact@v4
      with:
        name: function-discovery
        path: |
          functions.txt
          julia_files.txt

  # Generate LLVM IR for discovered functions
  llvm-ir-generation:
    name: üîß LLVM IR Generation
    needs: discover-functions
    runs-on: ubuntu-latest
    if: needs.discover-functions.outputs.function_count > 0
    strategy:
      matrix:
        optimization: ["-O0", "-O2", "-O3"]
    steps:
    - uses: actions/checkout@v4
    - uses: julia-actions/setup-julia@v1
      with:
        version: '1.10'
    
    - name: ‚¨áÔ∏è Download Function Discovery
      uses: actions/download-artifact@v4
      with:
        name: function-discovery
    
    - name: üîß Generate LLVM IR for Repository Functions
      run: |
        mkdir -p llvm-ir-output
        
        julia ${{ matrix.optimization }} -e '
        using InteractiveUtils
        
        function load_and_analyze_functions()
            println("=== Loading and analyzing repository functions ===")
            
            # Read discovered functions
            functions = []
            if isfile("functions.txt")
                for line in readlines("functions.txt")
                    parts = split(line, ",")
                    if length(parts) >= 4
                        push!(functions, (parts[1], parse(Int, parts[2]), parts[3], parts[4]))
                    end
                end
            end
            
            println("Processing $(length(functions)) functions")
            
            # Load Julia files into current scope
            julia_files = readlines("julia_files.txt")
            loaded_functions = Dict()
            
            for file_path in julia_files
                try
                    println("Loading $file_path")
                    include(file_path)
                    println("‚úÖ Successfully loaded $file_path")
                catch e
                    println("‚ö†Ô∏è  Could not load $file_path: $e")
                end
            end
            
            # Try to generate IR for each discovered function
            successful_ir = 0
            failed_ir = 0
            
            for (file, line, func_name, func_type) in functions
                try
                    # Try to get the function from current scope
                    if isdefined(Main, Symbol(func_name))
                        func_obj = getfield(Main, Symbol(func_name))
                        
                        if func_obj isa Function
                            println("\\nGenerating IR for: $func_name")
                            
                            # Try different argument types
                            test_args = [
                                (UInt32(123),),
                                (UInt64(456),),
                                (Int32(789),),
                                (Int64(101112),),
                                (Float64(3.14),),
                                (UInt32(1), UInt32(2)),
                                (Int64(5), Int64(10))
                            ]
                            
                            ir_generated = false
                            for args in test_args
                                try
                                    # Check if function accepts these arguments
                                    methods_list = methods(func_obj)
                                    if !isempty(methods_list)
                                        # Try to call with test args
                                        result = func_obj(args...)
                                        
                                        # Generate LLVM IR
                                        ir_output = @code_llvm func_obj(args...)
                                        
                                        # Save IR to file
                                        filename = "llvm-ir-output/$(func_name)_${{ matrix.optimization }}_$(hash(args)).ll"
                                        open(filename, "w") do io
                                            println(io, "; LLVM IR for $func_name")
                                            println(io, "; File: $file:$line")
                                            println(io, "; Optimization: ${{ matrix.optimization }}")
                                            println(io, "; Args: $args")
                                            println(io, "; Julia version: $(VERSION)")
                                            println(io, "")
                                            print(io, ir_output)
                                        end
                                        
                                        println("‚úÖ IR saved to $filename")
                                        successful_ir += 1
                                        ir_generated = true
                                        break
                                    end
                                catch e
                                    # Try next argument combination
                                    continue
                                end
                            end
                            
                            if !ir_generated
                                println("‚ö†Ô∏è  Could not generate IR for $func_name (no compatible arguments)")
                                failed_ir += 1
                            end
                        else
                            println("‚ö†Ô∏è  $func_name is not a function ($func_type)")
                        end
                    else
                        println("‚ö†Ô∏è  Function $func_name not found in scope")
                        failed_ir += 1
                    end
                catch e
                    println("‚ùå Error processing $func_name: $e")
                    failed_ir += 1
                end
            end
            
            println("\\n=== IR Generation Summary ===")
            println("Successful: $successful_ir")
            println("Failed: $failed_ir")
            println("Total: $(successful_ir + failed_ir)")
            
            return successful_ir > 0
        end
        
        success = load_and_analyze_functions()
        exit(success ? 0 : 1)
        '
    
    - name: üìä Analyze Generated IR
      run: |
        echo "# üîß LLVM IR Analysis Report (${{ matrix.optimization }})" > ir-analysis-${{ matrix.optimization }}.md
        echo "" >> ir-analysis-${{ matrix.optimization }}.md
        echo "Generated on: $(date)" >> ir-analysis-${{ matrix.optimization }}.md
        echo "Optimization level: ${{ matrix.optimization }}" >> ir-analysis-${{ matrix.optimization }}.md
        echo "" >> ir-analysis-${{ matrix.optimization }}.md
        
        total_files=0
        analyzed_files=0
        
        for file in llvm-ir-output/*.ll; do
          if [ -f "$file" ]; then
            total_files=$((total_files + 1))
            echo "## üìÑ $(basename $file)" >> ir-analysis-${{ matrix.optimization }}.md
            echo "" >> ir-analysis-${{ matrix.optimization }}.md
            
            # Basic analysis
            instr_count=$(grep -cE "^\s*%" "$file" 2>/dev/null || echo "0")
            func_calls=$(grep -c "call " "$file" 2>/dev/null || echo "0")
            loads=$(grep -c "load " "$file" 2>/dev/null || echo "0")
            stores=$(grep -c "store " "$file" 2>/dev/null || echo "0")
            
            echo "- **Instructions**: $instr_count" >> ir-analysis-${{ matrix.optimization }}.md
            echo "- **Function calls**: $func_calls" >> ir-analysis-${{ matrix.optimization }}.md
            echo "- **Loads**: $loads" >> ir-analysis-${{ matrix.optimization }}.md
            echo "- **Stores**: $stores" >> ir-analysis-${{ matrix.optimization }}.md
            
            # Check for potential issues
            issues=""
            if grep -q "overflow" "$file" 2>/dev/null; then
              issues="$issues\\n- ‚ö†Ô∏è Potential overflow detected"
            fi
            if grep -q "unreachable" "$file" 2>/dev/null; then
              issues="$issues\\n- ‚ö†Ô∏è Unreachable code detected"  
            fi
            if grep -q "julia.gc_alloc" "$file" 2>/dev/null; then
              issues="$issues\\n- ‚ÑπÔ∏è GC allocations detected"
            fi
            if grep -qE "addrspace\(1[0-9]+\)" "$file" 2>/dev/null; then
              issues="$issues\\n- ‚ÑπÔ∏è Julia-specific address spaces used"
            fi
            
            if [ -n "$issues" ]; then
              echo -e "$issues" >> ir-analysis-${{ matrix.optimization }}.md
            else
              echo "- ‚úÖ No obvious issues detected" >> ir-analysis-${{ matrix.optimization }}.md
            fi
            
            echo "" >> ir-analysis-${{ matrix.optimization }}.md
            analyzed_files=$((analyzed_files + 1))
          fi
        done
        
        echo "## üìà Summary" >> ir-analysis-${{ matrix.optimization }}.md
        echo "- Total IR files: $total_files" >> ir-analysis-${{ matrix.optimization }}.md
        echo "- Analyzed files: $analyzed_files" >> ir-analysis-${{ matrix.optimization }}.md
        echo "- Success rate: $(( analyzed_files * 100 / total_files ))%" >> ir-analysis-${{ matrix.optimization }}.md
    
    - name: ‚¨ÜÔ∏è Upload LLVM IR and Analysis
      uses: actions/upload-artifact@v4
      with:
        name: llvm-ir-${{ matrix.optimization }}
        path: |
          llvm-ir-output/
          ir-analysis-${{ matrix.optimization }}.md

  # Performance analysis using actual repo functions
  performance-analysis:
    name: ‚ö° Performance Analysis
    needs: [discover-functions, llvm-ir-generation]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: julia-actions/setup-julia@v1
      with:
        version: '1.10'
    
    - name: ‚¨áÔ∏è Download Artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: '*'
        merge-multiple: true
    
    - name: ‚ö° Benchmark Repository Functions
      run: |
        julia -e '
        using Pkg
        Pkg.add("BenchmarkTools")
        using BenchmarkTools, Statistics, InteractiveUtils
        
        function benchmark_repo_functions()
            println("=== Performance Analysis of Repository Functions ===")
            
            # Load functions
            functions = []
            if isfile("functions.txt")
                for line in readlines("functions.txt")
                    parts = split(line, ",")
                    if length(parts) >= 4
                        push!(functions, (parts[1], parse(Int, parts[2]), parts[3], parts[4]))
                    end
                end
            end
            
            # Load Julia files
            julia_files = readlines("julia_files.txt")
            for file_path in julia_files
                try
                    include(file_path)
                catch e
                    println("‚ö†Ô∏è  Could not load $file_path: $e")
                end
            end
            
            # Benchmark each function
            benchmark_results = []
            
            for (file, line, func_name, func_type) in functions
                if isdefined(Main, Symbol(func_name))
                    func_obj = getfield(Main, Symbol(func_name))
                    
                    if func_obj isa Function
                        println("\\nBenchmarking: $func_name")
                        
                        test_args = [
                            (UInt32(123),),
                            (UInt64(456),), 
                            (Int32(789),),
                            (Int64(101112),),
                            (Float64(3.14),)
                        ]
                        
                        for args in test_args
                            try
                                # Test if function works with these args
                                result = func_obj(args...)
                                
                                # Benchmark
                                bench = @benchmark $func_obj($(args...)) samples=100 evals=10
                                
                                median_time = median(bench.times)
                                mean_time = mean(bench.times)
                                memory_usage = bench.memory
                                
                                println("  Args $args:")
                                println("    Median: $(median_time) ns")
                                println("    Memory: $(memory_usage) bytes")
                                
                                push!(benchmark_results, (func_name, args, median_time, memory_usage))
                                
                                # Warnings
                                if median_time > 100000  # > 100Œºs
                                    println("    ‚ö†Ô∏è High execution time")
                                end
                                if memory_usage > 1000
                                    println("    ‚ö†Ô∏è High memory usage")
                                end
                                
                                break  # Use first working args
                            catch e
                                continue
                            end
                        end
                    end
                end
            end
            
            # Generate performance report
            println("\\n=== Performance Report ===")
            println("Benchmarked $(length(benchmark_results)) function calls")
            
            if !isempty(benchmark_results)
                times = [r[3] for r in benchmark_results]
                memories = [r[4] for r in benchmark_results]
                
                println("Time statistics:")
                println("  Median: $(median(times)) ns")
                println("  Mean: $(mean(times)) ns") 
                println("  Min/Max: $(minimum(times))/$(maximum(times)) ns")
                
                println("Memory statistics:")
                println("  Median: $(median(memories)) bytes")
                println("  Mean: $(mean(memories)) bytes")
                println("  Min/Max: $(minimum(memories))/$(maximum(memories)) bytes")
            end
            
            return !isempty(benchmark_results)
        end
        
        success = benchmark_repo_functions()
        exit(success ? 0 : 1)
        '

  # Generate comprehensive report
  final-report:
    name: üìã Generate Final Report
    needs: [discover-functions, llvm-ir-generation, performance-analysis]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: ‚¨áÔ∏è Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: '*'
        merge-multiple: true
    
    - name: üìã Generate Comprehensive Report
      run: |
        echo "# üîß LLVM IR Analysis - Comprehensive Report" > FINAL_REPORT.md
        echo "" >> FINAL_REPORT.md
        echo "**Generated**: $(date)" >> FINAL_REPORT.md
        echo "**Repository**: ${{ github.repository }}" >> FINAL_REPORT.md
        echo "**Commit**: ${{ github.sha }}" >> FINAL_REPORT.md
        echo "" >> FINAL_REPORT.md
        
        echo "## üìä Results Summary" >> FINAL_REPORT.md
        echo "| Phase | Status |" >> FINAL_REPORT.md
        echo "|-------|--------|" >> FINAL_REPORT.md
        echo "| Function Discovery | ${{ needs.discover-functions.result }} |" >> FINAL_REPORT.md
        echo "| LLVM IR Generation | ${{ needs.llvm-ir-generation.result }} |" >> FINAL_REPORT.md
        echo "| Performance Analysis | ${{ needs.performance-analysis.result }} |" >> FINAL_REPORT.md
        echo "" >> FINAL_REPORT.md
        
        echo "## üîç Discovery Results" >> FINAL_REPORT.md
        if [ -f "functions.txt" ]; then
          func_count=$(wc -l < functions.txt)
          echo "- **Functions found**: $func_count" >> FINAL_REPORT.md
          echo "- **Function details**:" >> FINAL_REPORT.md
          echo '```' >> FINAL_REPORT.md
          head -20 functions.txt >> FINAL_REPORT.md
          if [ $(wc -l < functions.txt) -gt 20 ]; then
            echo "... (showing first 20 of $func_count functions)" >> FINAL_REPORT.md
          fi
          echo '```' >> FINAL_REPORT.md
        fi
        echo "" >> FINAL_REPORT.md
        
        echo "## üîß LLVM IR Generation" >> FINAL_REPORT.md
        ir_count=$(find . -name "*.ll" 2>/dev/null | wc -l)
        echo "- **IR files generated**: $ir_count" >> FINAL_REPORT.md
        
        if [ $ir_count -gt 0 ]; then
          echo "- **Optimization levels**: O0, O2, O3" >> FINAL_REPORT.md
          echo "- **Sample IR files**:" >> FINAL_REPORT.md
          find . -name "*.ll" 2>/dev/null | head -10 | while read file; do
            echo "  - $(basename $file)" >> FINAL_REPORT.md
          done
        fi
        echo "" >> FINAL_REPORT.md
        
        echo "## üéØ Key Findings" >> FINAL_REPORT.md
        if [ "${{ needs.discover-functions.result }}" = "success" ]; then
          echo "‚úÖ **Function discovery successful** - Found ${{ needs.discover-functions.outputs.function_count }} functions" >> FINAL_REPORT.md
        else
          echo "‚ùå **Function discovery failed** - Check repository structure" >> FINAL_REPORT.md
        fi
        
        if [ "${{ needs.llvm-ir-generation.result }}" = "success" ]; then
          echo "‚úÖ **LLVM IR generation successful** - Generated $ir_count IR files" >> FINAL_REPORT.md
        else
          echo "‚ùå **LLVM IR generation failed** - Check function compatibility" >> FINAL_REPORT.md
        fi
        
        if [ "${{ needs.performance-analysis.result }}" = "success" ]; then
          echo "‚úÖ **Performance analysis completed**" >> FINAL_REPORT.md
        else
          echo "‚ö†Ô∏è **Performance analysis had issues**" >> FINAL_REPORT.md
        fi
        echo "" >> FINAL_REPORT.md
        
        echo "## üìÅ Available Artifacts" >> FINAL_REPORT.md
        echo "- **function-discovery**: Function inventory and file list" >> FINAL_REPORT.md
        echo "- **llvm-ir-O0/O2/O3**: Generated LLVM IR at different optimization levels" >> FINAL_REPORT.md
        echo "- **final-report**: This comprehensive report" >> FINAL_REPORT.md
        echo "" >> FINAL_REPORT.md
        
        echo "---" >> FINAL_REPORT.md
        echo "*Analysis completed with Julia $(julia --version | cut -d' ' -f3)*" >> FINAL_REPORT.md
    
    - name: ‚¨ÜÔ∏è Upload Final Report
      uses: actions/upload-artifact@v4
      with:
        name: final-report
        path: FINAL_REPORT.md